<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:fn="http://www.w3.org/2005/02/xpath-functions">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../otp_doc.css" type="text/css">
<title>Erlang -- Advanced</title>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#ff00ff" alink="#ff0000"><div id="container">
<script id="js" type="text/javascript" language="JavaScript" src="../js/flipmenu/flipmenu.js"></script><script id="js2" type="text/javascript" src="../js/erlresolvelinks.js"></script><script language="JavaScript" type="text/javascript">
            <!--
              function getWinHeight() {
                var myHeight = 0;
                if( typeof( window.innerHeight ) == 'number' ) {
                  //Non-IE
                  myHeight = window.innerHeight;
                } else if( document.documentElement && ( document.documentElement.clientWidth ||
                                                         document.documentElement.clientHeight ) ) {
                  //IE 6+ in 'standards compliant mode'
                  myHeight = document.documentElement.clientHeight;
                } else if( document.body && ( document.body.clientWidth || document.body.clientHeight ) ) {
                  //IE 4 compatible
                  myHeight = document.body.clientHeight;
                }
                return myHeight;
              }

              function setscrollpos() {
                var objf=document.getElementById('loadscrollpos');
                 document.getElementById("leftnav").scrollTop = objf.offsetTop - getWinHeight()/2;
              }

              function addEvent(obj, evType, fn){
                if (obj.addEventListener){
                obj.addEventListener(evType, fn, true);
                return true;
              } else if (obj.attachEvent){
                var r = obj.attachEvent("on"+evType, fn);
                return r;
              } else {
                return false;
              }
             }

             addEvent(window, 'load', setscrollpos);

             //--></script><div id="leftnav"><div class="innertube">
<img alt="Erlang logo" src="../erlang-logo.png"><br><small><a href="users_guide.html">User's Guide</a><br><a href="../pdf/otp-system-documentation-6.4.1.6.pdf">PDF</a><br><a href="../index.html">Top</a></small><p><strong>Efficiency Guide</strong><br><strong>User's Guide</strong><br><small>Version 6.4.1.6</small></p>
<br><a href="javascript:openAllFlips()">Expand All</a><br><a href="javascript:closeAllFlips()">Contract All</a><p><small><strong>Chapters</strong></small></p>
<ul class="flipMenu" imagepath="../js/flipmenu">
<li id="no" title="Introduction" expanded="false">Introduction<ul>
<li><a href="introduction.html">
              Top of chapter
            </a></li>
<li title="Purpose"><a href="introduction.html#idp27060704">Purpose</a></li>
<li title="Prerequisites"><a href="introduction.html#idp27036960">Prerequisites</a></li>
</ul>
</li>
<li id="no" title="The Eight Myths of Erlang Performance" expanded="false">The Eight Myths of Erlang Performance<ul>
<li><a href="myths.html">
              Top of chapter
            </a></li>
<li title="Myth: Funs are slow"><a href="myths.html#idp27034016">Myth: Funs are slow</a></li>
<li title="Myth: List comprehensions are slow"><a href="myths.html#idp27030400">Myth: List comprehensions are slow</a></li>
<li title="Myth: Tail-recursive functions are MUCH faster
    than recursive functions"><a href="myths.html#idp27028240">Myth: Tail-recursive functions are MUCH faster
    than recursive functions</a></li>
<li title="Myth: '++' is always bad"><a href="myths.html#idp27018640">Myth: '++' is always bad</a></li>
<li title="Myth: Strings are slow"><a href="myths.html#idp26896240">Myth: Strings are slow</a></li>
<li title="Myth: Repairing a Dets file is very slow"><a href="myths.html#idp26483504">Myth: Repairing a Dets file is very slow</a></li>
<li title="Myth: BEAM is a stack-based byte-code virtual machine (and therefore slow)"><a href="myths.html#idp26482032">Myth: BEAM is a stack-based byte-code virtual machine (and therefore slow)</a></li>
<li title="Myth: Use '_' to speed up your program when a variable is not used"><a href="myths.html#idp26480432">Myth: Use '_' to speed up your program when a variable is not used</a></li>
</ul>
</li>
<li id="no" title="Common Caveats" expanded="false">Common Caveats<ul>
<li><a href="commoncaveats.html">
              Top of chapter
            </a></li>
<li title="The timer module"><a href="commoncaveats.html#idp26780384">The timer module</a></li>
<li title="list_to_atom/1"><a href="commoncaveats.html#idp26576912">list_to_atom/1</a></li>
<li title="length/1"><a href="commoncaveats.html#idp26468352">length/1</a></li>
<li title="setelement/3"><a href="commoncaveats.html#idp26573248">setelement/3</a></li>
<li title="size/1"><a href="commoncaveats.html#idp26802608">size/1</a></li>
<li title="split_binary/2"><a href="commoncaveats.html#idp26407520">split_binary/2</a></li>
<li title="The '--' operator"><a href="commoncaveats.html#idp26659200">The '--' operator</a></li>
</ul>
</li>
<li id="no" title="Constructing and matching binaries" expanded="false">Constructing and matching binaries<ul>
<li><a href="binaryhandling.html">
              Top of chapter
            </a></li>
<li title="How binaries are implemented"><a href="binaryhandling.html#idp26511712">How binaries are implemented</a></li>
<li title="Constructing binaries"><a href="binaryhandling.html#idp26710224">Constructing binaries</a></li>
<li title="Matching binaries"><a href="binaryhandling.html#idp27102384">Matching binaries</a></li>
</ul>
</li>
<li id="no" title="List handling" expanded="false">List handling<ul>
<li><a href="listHandling.html">
              Top of chapter
            </a></li>
<li title="Creating a list"><a href="listHandling.html#idp27180032">Creating a list</a></li>
<li title="List comprehensions"><a href="listHandling.html#idp27190960">List comprehensions</a></li>
<li title="Deep and flat lists"><a href="listHandling.html#idp27198656">Deep and flat lists</a></li>
<li title="Why you should not worry about recursive lists functions"><a href="listHandling.html#idp27215104">Why you should not worry about recursive lists functions</a></li>
</ul>
</li>
<li id="no" title="Functions" expanded="false">Functions<ul>
<li><a href="functions.html">
              Top of chapter
            </a></li>
<li title="Pattern matching"><a href="functions.html#idp27229648">Pattern matching</a></li>
<li title="Function Calls "><a href="functions.html#idp27255376">Function Calls </a></li>
<li title="Memory usage in recursion"><a href="functions.html#idp27272592">Memory usage in recursion</a></li>
</ul>
</li>
<li id="no" title="Tables and databases" expanded="false">Tables and databases<ul>
<li><a href="tablesDatabases.html">
              Top of chapter
            </a></li>
<li title="Ets, Dets and Mnesia"><a href="tablesDatabases.html#idp27283408">Ets, Dets and Mnesia</a></li>
<li title="Ets specific"><a href="tablesDatabases.html#idp27329888">Ets specific</a></li>
<li title="Mnesia specific"><a href="tablesDatabases.html#idp27342304">Mnesia specific</a></li>
</ul>
</li>
<li id="no" title="Processes" expanded="false">Processes<ul>
<li><a href="processes.html">
              Top of chapter
            </a></li>
<li title="Creation of an Erlang process"><a href="processes.html#idp27354768">Creation of an Erlang process</a></li>
<li title="Process messages"><a href="processes.html#idp27372544">Process messages</a></li>
<li title="The SMP emulator"><a href="processes.html#idp27395632">The SMP emulator</a></li>
</ul>
</li>
<li id="no" title="Drivers" expanded="false">Drivers<ul>
<li><a href="drivers.html">
              Top of chapter
            </a></li>
<li title="Drivers and concurrency"><a href="drivers.html#idp27408000">Drivers and concurrency</a></li>
<li title="Avoiding copying of binaries when calling a driver"><a href="drivers.html#idp27412880">Avoiding copying of binaries when calling a driver</a></li>
<li title="Returning small binaries from a driver"><a href="drivers.html#idp27420992">Returning small binaries from a driver</a></li>
<li title="Returning big binaries without copying from a driver"><a href="drivers.html#idp27425152">Returning big binaries without copying from a driver</a></li>
</ul>
</li>
<li id="loadscrollpos" title="Advanced" expanded="true">Advanced<ul>
<li><a href="advanced.html">
              Top of chapter
            </a></li>
<li title="Memory"><a href="advanced.html#idp27442048">Memory</a></li>
<li title="System limits"><a href="advanced.html#idp27484912">System limits</a></li>
</ul>
</li>
<li id="no" title="Profiling" expanded="false">Profiling<ul>
<li><a href="profiling.html">
              Top of chapter
            </a></li>
<li title="Do not guess about performance - profile"><a href="profiling.html#idp27521472">Do not guess about performance - profile</a></li>
<li title="Big systems"><a href="profiling.html#idp27531296">Big systems</a></li>
<li title="What to look for"><a href="profiling.html#idp27533680">What to look for</a></li>
<li title="Tools"><a href="profiling.html#idp27540576">Tools</a></li>
<li title="Benchmarking"><a href="profiling.html#idp27601392">Benchmarking</a></li>
</ul>
</li>
</ul>
</div></div>
<div id="content">
<div class="innertube">
<h1>10 Advanced</h1>
  

  <h3><a name="idp27442048">10.1 
        Memory</a></h3>
    
    <p>A good start when programming efficiently is to have knowledge about
      how much memory different data types and operations require. It is
      implementation-dependent how much memory the Erlang data types and
      other items consume, but here are some figures for the
      erts-5.2 system (OTP release R9B). (There have been no significant
      changes in R13.)</p>

      <p>The unit of measurement is memory words. There exists both a 32-bit
      and a 64-bit implementation, and a word is therefore, 4 bytes or
      8 bytes, respectively.</p>
    <table border="1" cellpadding="2" cellspacing="0">
<tr>
        <td align="left" valign="middle">Data type</td>
        <td align="left" valign="middle">Memory size</td>
      </tr>
<tr>
        <td align="left" valign="middle">Small integer</td>
        <td align="left" valign="middle">1 word<br>
On 32-bit architectures: -134217729 &lt; i &lt; 134217728 (28 bits)<br>
On 64-bit architectures: -576460752303423489 &lt; i &lt; 576460752303423488 (60 bits)</td>
      </tr>
<tr>
        <td align="left" valign="middle">Big integer</td>
        <td align="left" valign="middle">3..N words</td>
      </tr>
<tr>
        <td align="left" valign="middle">Atom</td>
        <td align="left" valign="middle">1 word. Note: an atom refers into
	an atom table which also consumes memory.
	The atom text is stored once for each unique atom in this table.
	The atom table is <strong>not</strong> garbage-collected.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Float</td>
        <td align="left" valign="middle">On 32-bit architectures: 4 words        <br>
On 64-bit architectures: 3 words</td>
      </tr>
<tr>
        <td align="left" valign="middle">Binary</td>
        <td align="left" valign="middle">3..6 + data (can be shared)</td>
      </tr>
<tr>
        <td align="left" valign="middle">List</td>
        <td align="left" valign="middle">1 word + 1 word per element + the size of each element</td>
      </tr>
<tr>
        <td align="left" valign="middle">String (is the same as a list of integers)</td>
        <td align="left" valign="middle">1 word + 2 words per character</td>
      </tr>
<tr>
        <td align="left" valign="middle">Tuple</td>
        <td align="left" valign="middle">2 words + the size of each element</td>
      </tr>
<tr>
        <td align="left" valign="middle">Pid</td>
        <td align="left" valign="middle">1 word for a process identifier from the current local node, and 5 words for a process identifier from another node. Note: a process identifier refers into a process table and a node table which also consumes memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Port</td>
        <td align="left" valign="middle">1 word for a port identifier from the current local node, and 5 words for a port identifier from another node. Note: a port identifier refers into a port table and a node table which also consumes memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Reference</td>
        <td align="left" valign="middle">On 32-bit architectures: 5 words for a reference from the current local node, and 7 words for a reference from another node.        <br>
On 64-bit architectures: 4 words for a reference from the current local node, and 6 words for a reference from another node. Note: a reference refers into a node table which also consumes memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Fun</td>
        <td align="left" valign="middle">9..13 words + size of environment. Note: a fun refers into a fun table which also consumes memory.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Ets table</td>
        <td align="left" valign="middle">Initially 768 words + the size of each element (6 words + size of Erlang data). The table will grow when necessary.</td>
      </tr>
<tr>
        <td align="left" valign="middle">Erlang process</td>
        <td align="left" valign="middle">327 words when spawned including a heap of 233 words.</td>
      </tr>
</table>
<em>Table
        10.1:
         
        Memory size of different data types</em>
  

  <h3><a name="idp27484912">10.2 
        System limits</a></h3>
    
    <p>The Erlang language specification puts no limits on number of processes,
     length of atoms etc., but for performance and memory saving reasons,
      there will always be limits in a practical implementation of the Erlang
      language and execution environment.</p>
    <dl>
      <dt><strong><strong>Processes</strong></strong></dt>
      <dd>
        <p>The maximum number of simultaneously alive Erlang processes is
          by default 32768. This limit can be configured at startup,
	  for more information see the
	  <span class="bold_code"><a href="javascript:erlhref('../../','erts','erl.html#max_processes');"><span class="code">+P</span></a></span>
	  command line flag of
	  <span class="bold_code"><a href="javascript:erlhref('../../','erts','erl.html');"><span class="code">erl(1)</span></a></span>.</p>
      </dd>
      <dt><strong><strong>Distributed nodes</strong></strong></dt>
      <dd>
        <dl>
          <dt><strong>Known nodes</strong></dt>
          <dd>
            <p>A remote node Y has to be known to node X if there exist
              any pids, ports, references, or funs (Erlang data types) from Y
              on X, or if X and Y are connected. The maximum number of remote
              nodes simultaneously/ever known to a node is limited by the
              <span class="bold_code"><a href="#atoms">maximum number of atoms</a></span>
              available for node names. All data concerning remote nodes,
              except for the node name atom, are garbage-collected.</p>
          </dd>
          <dt><strong>Connected nodes</strong></dt>
          <dd>The maximum number of simultaneously connected nodes is limited by
           either the maximum number of simultaneously known remote nodes,
          <span class="bold_code"><a href="#ports">the maximum number of (Erlang) ports</a></span>
           available, or
          <span class="bold_code"><a href="#files_sockets">the maximum number of sockets</a></span>
           available.</dd>
        </dl>
      </dd>
      <dt><strong><strong>Characters in an atom</strong></strong></dt>
      <dd>255</dd>
      <dt><strong><strong>Atoms </strong></strong></dt>
      <dd>      <a name="atoms"></a>
	By default, the maximum number of atoms is 1048576.
	This limit can be raised or lowered using the <span class="code">+t</span> option.</dd>
      <dt><strong><strong>Ets-tables</strong></strong></dt>
      <dd>The default is 1400, can be changed with the environment variable <span class="code">ERL_MAX_ETS_TABLES</span>.</dd>
      <dt><strong><strong>Elements in a tuple</strong></strong></dt>
      <dd>The maximum number of elements in a tuple is 67108863 (26 bit unsigned integer). Other factors
       such as the available memory can of course make it hard to create a tuple of that size. </dd>
      <dt><strong><strong>Size of binary</strong></strong></dt>
      <dd>In the 32-bit implementation of Erlang, 536870911 bytes is the
       largest binary that can be constructed or matched using the bit syntax.
       (In the 64-bit implementation, the maximum size is 2305843009213693951 bytes.)
       If the limit is exceeded, bit syntax construction will fail with a
      <span class="code">system_limit</span> exception, while any attempt to match a binary that is
       too large will fail.
       This limit is enforced starting with the R11B-4 release; in earlier releases,
       operations on too large binaries would in general either fail or give incorrect
       results.
       In future releases of Erlang/OTP, other operations that create binaries (such as
      <span class="code">list_to_binary/1</span>) will probably also enforce the same limit.</dd>
      <dt><strong><strong>Total amount of data allocated by an Erlang node</strong></strong></dt>
      <dd>The Erlang runtime system can use the complete 32 (or 64) bit address space,
       but the operating system often limits a single process to use less than that.</dd>
      <dt><strong><strong>Length of a node name</strong></strong></dt>
      <dd>An Erlang node name has the form host@shortname or host@longname. The node name is 
       used as an atom within the system so the maximum size of 255 holds for the node name too.</dd>
      <dt><strong><strong>Open ports</strong></strong></dt>
      <dd>
        <a name="ports"></a>
	  <p>The maximum number of simultaneously open Erlang ports is
	  often by default 16384. This limit can be configured at startup,
	  for more information see the
	  <span class="bold_code"><a href="javascript:erlhref('../../','erts','erl.html#max_ports');"><span class="code">+Q</span></a></span>
	  command line flag of
	  <span class="bold_code"><a href="javascript:erlhref('../../','erts','erl.html');"><span class="code">erl(1)</span></a></span>.</p>
      </dd>
      <dt><strong><strong>Open files, and sockets</strong></strong></dt>
      <dd>      <a name="files_sockets"></a>

       The maximum number of simultaneously open files and sockets
       depend on
      <span class="bold_code"><a href="#ports">the maximum number of Erlang ports</a></span>
       available, and operating system specific settings and limits.</dd>
      <dt><strong><strong>Number of arguments to a function or fun</strong></strong></dt>
      <dd>255</dd>
    </dl>
  
</div>
<div class="footer">
<hr>
<p>Copyright © 2001-2018 Ericsson AB. All Rights Reserved.</p>
</div>
</div>
</div></body>
</html>
