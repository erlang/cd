.TH erl_internal 3 "stdlib 3.4.5" "Ericsson AB" "Erlang Module Definition"
.SH NAME
erl_internal \- Internal Erlang definitions.
.SH DESCRIPTION
.LP
This module defines Erlang BIFs, guard tests, and operators\&. This module is only of interest to programmers who manipulate Erlang code\&.
.SH EXPORTS
.LP
.nf

.B
add_predefined_functions(Forms) -> UpdatedForms
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Forms = [\fBerl_parse:abstract_form()\fR\& | \fBerl_parse:form_info()\fR\&]
.br
UpdatedForms = 
.br
    [\fBerl_parse:abstract_form()\fR\& | \fBerl_parse:form_info()\fR\&]
.br
.RE
.RE
.RS
.LP
Adds to \fIForms\fR\& the code for the standard pre-defined functions (such as \fImodule_info/0\fR\&) that are to be included in every module\&.
.RE
.LP
.nf

.B
arith_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is an arithmetic operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
bif(Name, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIName/Arity\fR\& is an Erlang BIF that is automatically recognized by the compiler, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
bool_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a Boolean operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
comp_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a comparison operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
guard_bif(Name, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIName/Arity\fR\& is an Erlang BIF that is allowed in guards, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
list_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a list operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
op_type(OpName, Arity) -> Type
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
Type = arith | bool | comp | list | send
.br
.RE
.RE
.RS
.LP
Returns the \fIType\fR\& of operator that \fIOpName/Arity\fR\& belongs to, or generates a \fIfunction_clause\fR\& error if it is not an operator\&.
.RE
.LP
.nf

.B
send_op(OpName, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
OpName = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOpName/Arity\fR\& is a send operator, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
type_test(Name, Arity) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = atom()
.br
Arity = arity()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIName/Arity\fR\& is a valid Erlang type test, otherwise \fIfalse\fR\&\&.
.RE