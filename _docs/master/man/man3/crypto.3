.TH crypto 3 "crypto 4.8" "Ericsson AB" "Erlang Module Definition"
.SH NAME
crypto \- Crypto Functions
.SH DESCRIPTION
.LP
This module provides a set of cryptographic functions\&.
.RS 2
.TP 2
.B
Hash functions:

.RS 2
.TP 2
.B
SHA1, SHA2:
 Secure Hash Standard [FIPS PUB 180-4] 
.TP 2
.B
SHA3:
 SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions [FIPS PUB 202] 
.TP 2
.B
BLAKE2:
BLAKE2 â€” fast secure hashing
.TP 2
.B
MD5:
The MD5 Message Digest Algorithm [RFC 1321]
.TP 2
.B
MD4:
The MD4 Message Digest Algorithm [RFC 1320]
.RE
.RS 2
.LP

.RE
.TP 2
.B
MACs - Message Authentication Codes:

.RS 2
.TP 2
.B
Hmac functions:
 Keyed-Hashing for Message Authentication [RFC 2104] 
.TP 2
.B
Cmac functions:
 The AES-CMAC Algorithm [RFC 4493] 
.TP 2
.B
POLY1305:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Symmetric Ciphers:

.RS 2
.TP 2
.B
DES, 3DES and AES:
Block Cipher Techniques [NIST]
.TP 2
.B
Blowfish:
 Fast Software Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp\&. 191-204\&. 
.TP 2
.B
Chacha20:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.TP 2
.B
Chacha20_poly1305:
 ChaCha20 and Poly1305 for IETF Protocols [RFC 7539] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Modes:

.RS 2
.TP 2
.B
ECB, CBC, CFB, OFB and CTR:
 Recommendation for Block Cipher Modes of Operation: Methods and Techniques [NIST SP 800-38A] 
.TP 2
.B
GCM:
 Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC [NIST SP 800-38D] 
.TP 2
.B
CCM:
 Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality [NIST SP 800-38C] 
.RE
.RS 2
.LP

.RE
.TP 2
.B
Asymetric Ciphers - Public Key Techniques:

.RS 2
.TP 2
.B
RSA:
 PKCS #1: RSA Cryptography Specifications [RFC 3447] 
.TP 2
.B
DSS:
 Digital Signature Standard (DSS) [FIPS 186-4] 
.TP 2
.B
ECDSA:
 Elliptic Curve Digital Signature Algorithm [ECDSA] 
.TP 2
.B
SRP:
 The SRP Authentication and Key Exchange System [RFC 2945] 
.RE
.RS 2
.LP

.RE
.RE
.LP

.RS -4
.B
Note:
.RE
The actual supported algorithms and features depends on their availability in the actual libcrypto used\&. See the crypto (App) about dependencies\&.
.LP
Enabling FIPS mode will also disable algorithms and features\&.

.LP
The CRYPTO User\&'s Guide has more information on FIPS, Engines and Algorithm Details like key lengths\&.
.SH DATA TYPES
.SS Ciphers, new API
.nf

\fBcipher()\fR\& = cipher_no_iv() | cipher_iv() | cipher_aead()
.br
.fi
.RS
.RE
.nf

\fBcipher_no_iv()\fR\& = 
.br
    aes_128_ecb | aes_192_ecb | aes_256_ecb | blowfish_ecb |
.br
    des_ecb | rc4
.br
.fi
.RS
.RE
.nf

\fBcipher_iv()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_128_cfb128 |
.br
    aes_192_cfb128 | aes_256_cfb128 | aes_128_cfb8 |
.br
    aes_192_cfb8 | aes_256_cfb8 | aes_128_ctr | aes_192_ctr |
.br
    aes_256_ctr | aes_ige256 | blowfish_cbc | blowfish_cfb64 |
.br
    blowfish_ofb64 | chacha20 | des_ede3_cbc | des_ede3_cfb |
.br
    des_cbc | des_cfb | rc2_cbc
.br
.fi
.RS
.RE
.nf

\fBcipher_aead()\fR\& = 
.br
    aes_128_ccm | aes_192_ccm | aes_256_ccm | aes_128_gcm |
.br
    aes_192_gcm | aes_256_gcm | chacha20_poly1305
.br
.fi
.RS
.LP
Ciphers known by the CRYPTO application when using the new API\&.
.LP
Note that this list might be reduced if the underlying libcrypto does not support all of them\&.
.RE
.nf

\fBcrypto_opts()\fR\& = boolean() | [crypto_opt()]
.br
.fi
.nf

\fBcrypto_opt()\fR\& = {encrypt, boolean()} | {padding, padding()}
.br
.fi
.RS
.LP
Selects encryption (\fI{encrypt,true}\fR\&) or decryption (\fI{encrypt,false}\fR\&) in the \fINew API\fR\& \&.
.RE
.nf

\fBpadding()\fR\& = cryptolib_padding() | otp_padding()
.br
.fi
.RS
.LP
This option handles padding in the last block\&. If not set, no padding is done and any bytes in the last unfilled block is silently discarded\&.
.RE
.nf

\fBcryptolib_padding()\fR\& = none | pkcs_padding
.br
.fi
.RS
.LP
The \fIcryptolib_padding\fR\& are paddings that may be present in the underlying cryptolib linked to the Erlang/OTP crypto app\&.
.LP
For OpenSSL, see the OpenSSL documentation\&. and find \fIEVP_CIPHER_CTX_set_padding()\fR\& in cryptolib for your linked version\&.
.RE
.nf

\fBotp_padding()\fR\& = zero | random
.br
.fi
.RS
.LP
Erlang/OTP adds a either padding of zeroes or padding with random bytes\&.
.RE
.SS Ciphers, old API
.nf

\fBblock_cipher_with_iv()\fR\& = 
.br
    cbc_cipher() | cfb_cipher() | blowfish_ofb64 | aes_ige256
.br
.fi
.RS
.RE
.nf

\fBblock_cipher_without_iv()\fR\& = ecb_cipher()
.br
.fi
.RS
.RE
.nf

\fBstream_cipher()\fR\& = ctr_cipher() | chacha20 | rc4
.br
.fi
.RS
.RE
.nf

\fBaead_cipher()\fR\& = aes_gcm | aes_ccm | chacha20_poly1305
.br
.fi
.RS
.RE
.nf

\fBcbc_cipher()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | blowfish_cbc |
.br
    des_cbc | des_ede3_cbc | rc2_cbc |
.br
    retired_cbc_cipher_aliases()
.br
.fi
.RS
.RE
.nf

\fBcfb_cipher()\fR\& = 
.br
    aes_128_cfb128 | aes_192_cfb128 | aes_256_cfb128 |
.br
    aes_128_cfb8 | aes_192_cfb8 | aes_256_cfb8 | blowfish_cfb64 |
.br
    des_cfb | des_ede3_cfb |
.br
    retired_cfb_cipher_aliases()
.br
.fi
.RS
.RE
.nf

\fBctr_cipher()\fR\& = 
.br
    aes_128_ctr | aes_192_ctr | aes_256_ctr |
.br
    retired_ctr_cipher_aliases()
.br
.fi
.RS
.RE
.nf

\fBecb_cipher()\fR\& = 
.br
    aes_128_ecb | aes_192_ecb | aes_256_ecb | blowfish_ecb |
.br
    retired_ecb_cipher_aliases()
.br
.fi
.RS
.LP
Ciphers known by the CRYPTO application when using the old API\&.
.LP
Note that this list might be reduced if the underlying libcrypto does not support all of them\&.
.RE
.nf

\fBretired_cbc_cipher_aliases()\fR\& = 
.br
    aes_cbc | aes_cbc128 | aes_cbc256 | des3_cbc | des_ede3
.br
.fi
.RS
.RE
.nf

\fBretired_cfb_cipher_aliases()\fR\& = 
.br
    aes_cfb8 | aes_cfb128 | des3_cbf | des3_cfb | des_ede3_cbf
.br
.fi
.RS
.RE
.nf

\fBretired_ctr_cipher_aliases()\fR\& = aes_ctr
.br
.fi
.RS
.RE
.nf

\fBretired_ecb_cipher_aliases()\fR\& = aes_ecb
.br
.fi
.RS
.LP
Alternative, old names of ciphers known by the CRYPTO application when using the old API\&. See Retired cipher names for names to use instead to be prepared for an easy convertion to the new API\&.
.LP
Note that this list might be reduced if the underlying libcrypto does not support all of them\&.
.RE
.SS Digests and hash
.nf

\fBhash_algorithm()\fR\& = 
.br
    sha1() |
.br
    sha2() |
.br
    sha3() |
.br
    blake2() |
.br
    ripemd160 |
.br
    compatibility_only_hash()
.br
.fi
.RS
.RE
.nf

\fBhmac_hash_algorithm()\fR\& = 
.br
    sha1() | sha2() | sha3() | compatibility_only_hash()
.br
.fi
.RS
.RE
.nf

\fBcmac_cipher_algorithm()\fR\& = 
.br
    aes_128_cbc | aes_192_cbc | aes_256_cbc | blowfish_cbc |
.br
    des_cbc | des_ede3_cbc | rc2_cbc | aes_128_cfb128 |
.br
    aes_192_cfb128 | aes_256_cfb128 | aes_128_cfb8 |
.br
    aes_192_cfb8 | aes_256_cfb8
.br
.fi
.RS
.RE
.nf

\fBrsa_digest_type()\fR\& = sha1() | sha2() | md5 | ripemd160
.br
.fi
.RS
.RE
.nf

\fBdss_digest_type()\fR\& = sha1() | sha2()
.br
.fi
.RS
.RE
.nf

\fBecdsa_digest_type()\fR\& = sha1() | sha2()
.br
.fi
.RS
.RE
.nf

\fBsha1()\fR\& = sha
.br
.fi
.nf

\fBsha2()\fR\& = sha224 | sha256 | sha384 | sha512
.br
.fi
.nf

\fBsha3()\fR\& = sha3_224 | sha3_256 | sha3_384 | sha3_512
.br
.fi
.nf

\fBblake2()\fR\& = blake2b | blake2s
.br
.fi
.RS
.RE
.nf

\fBcompatibility_only_hash()\fR\& = md5 | md4
.br
.fi
.RS
.LP
The \fIcompatibility_only_hash()\fR\& algorithms are recommended only for compatibility with existing applications\&.
.RE
.SS Elliptic Curves
.nf

\fBec_named_curve()\fR\& = 
.br
    brainpoolP160r1 | brainpoolP160t1 | brainpoolP192r1 |
.br
    brainpoolP192t1 | brainpoolP224r1 | brainpoolP224t1 |
.br
    brainpoolP256r1 | brainpoolP256t1 | brainpoolP320r1 |
.br
    brainpoolP320t1 | brainpoolP384r1 | brainpoolP384t1 |
.br
    brainpoolP512r1 | brainpoolP512t1 | c2pnb163v1 | c2pnb163v2 |
.br
    c2pnb163v3 | c2pnb176v1 | c2pnb208w1 | c2pnb272w1 |
.br
    c2pnb304w1 | c2pnb368w1 | c2tnb191v1 | c2tnb191v2 |
.br
    c2tnb191v3 | c2tnb239v1 | c2tnb239v2 | c2tnb239v3 |
.br
    c2tnb359v1 | c2tnb431r1 | ipsec3 | ipsec4 | prime192v1 |
.br
    prime192v2 | prime192v3 | prime239v1 | prime239v2 |
.br
    prime239v3 | prime256v1 | secp112r1 | secp112r2 | secp128r1 |
.br
    secp128r2 | secp160k1 | secp160r1 | secp160r2 | secp192k1 |
.br
    secp192r1 | secp224k1 | secp224r1 | secp256k1 | secp256r1 |
.br
    secp384r1 | secp521r1 | sect113r1 | sect113r2 | sect131r1 |
.br
    sect131r2 | sect163k1 | sect163r1 | sect163r2 | sect193r1 |
.br
    sect193r2 | sect233k1 | sect233r1 | sect239k1 | sect283k1 |
.br
    sect283r1 | sect409k1 | sect409r1 | sect571k1 | sect571r1 |
.br
    wtls1 | wtls10 | wtls11 | wtls12 | wtls3 | wtls4 | wtls5 |
.br
    wtls6 | wtls7 | wtls8 | wtls9
.br
.fi
.nf

\fBedwards_curve_dh()\fR\& = x25519 | x448
.br
.fi
.nf

\fBedwards_curve_ed()\fR\& = ed25519 | ed448
.br
.fi
.RS
.LP
Note that some curves are disabled if FIPS is enabled\&.
.RE
.nf

\fBec_explicit_curve()\fR\& = 
.br
    {Field :: ec_field(),
.br
     Curve :: ec_curve(),
.br
     BasePoint :: binary(),
.br
     Order :: binary(),
.br
     CoFactor :: none | binary()}
.br
.fi
.nf

\fBec_field()\fR\& = ec_prime_field() | ec_characteristic_two_field()
.br
.fi
.nf

\fBec_curve()\fR\& = 
.br
    {A :: binary(), B :: binary(), Seed :: none | binary()}
.br
.fi
.RS
.LP
Parametric curve definition\&.
.RE
.nf

\fBec_prime_field()\fR\& = {prime_field, Prime :: integer()}
.br
.fi
.nf

\fBec_characteristic_two_field()\fR\& = 
.br
    {characteristic_two_field,
.br
     M :: integer(),
.br
     Basis :: ec_basis()}
.br
.fi
.nf

\fBec_basis()\fR\& = 
.br
    {tpbasis, K :: integer() >= 0} |
.br
    {ppbasis,
.br
     K1 :: integer() >= 0,
.br
     K2 :: integer() >= 0,
.br
     K3 :: integer() >= 0} |
.br
    onbasis
.br
.fi
.RS
.LP
Curve definition details\&.
.RE
.SS Keys
.nf

\fBkey()\fR\& = iodata()
.br
.fi
.nf

\fBdes3_key()\fR\& = [key()]
.br
.fi
.RS
.LP
For keylengths, iv-sizes and blocksizes see the User\&'s Guide\&.
.LP
A key for des3 is a list of three iolists
.RE
.nf

\fBkey_integer()\fR\& = integer() | binary()
.br
.fi
.RS
.LP
Always \fIbinary()\fR\& when used as return value
.RE
.SS Public/Private Keys
.nf

\fBrsa_public()\fR\& = [key_integer()]
.br
.fi
.nf

\fBrsa_private()\fR\& = [key_integer()]
.br
.fi
.nf

\fBrsa_params()\fR\& = 
.br
    {ModulusSizeInBits :: integer(),
.br
     PublicExponent :: key_integer()}
.br
.fi
.RS
.LP
.nf
rsa_public() = [E, N]
.fi
.LP
.nf
rsa_private() = [E, N, D] | [E, N, D, P1, P2, E1, E2, C]
.fi
.LP
Where E is the public exponent, N is public modulus and D is the private exponent\&. The longer key format contains redundant information that will make the calculation faster\&. P1,P2 are first and second prime factors\&. E1,E2 are first and second exponents\&. C is the CRT coefficient\&. Terminology is taken from  RFC 3447\&.
.RE
.nf

\fBdss_public()\fR\& = [key_integer()]
.br
.fi
.nf

\fBdss_private()\fR\& = [key_integer()]
.br
.fi
.RS
.LP
.nf
dss_public() = [P, Q, G, Y] 
.fi
.LP
Where P, Q and G are the dss parameters and Y is the public key\&.
.LP
.nf
dss_private() = [P, Q, G, X] 
.fi
.LP
Where P, Q and G are the dss parameters and X is the private key\&.
.RE
.nf

\fBecdsa_public()\fR\& = key_integer()
.br
.fi
.nf

\fBecdsa_private()\fR\& = key_integer()
.br
.fi
.nf

\fBecdsa_params()\fR\& = ec_named_curve() | ec_explicit_curve()
.br
.fi
.RS
.RE
.nf

\fBeddsa_public()\fR\& = key_integer()
.br
.fi
.nf

\fBeddsa_private()\fR\& = key_integer()
.br
.fi
.nf

\fBeddsa_params()\fR\& = edwards_curve_ed()
.br
.fi
.RS
.RE
.nf

\fBsrp_public()\fR\& = key_integer()
.br
.fi
.nf

\fBsrp_private()\fR\& = key_integer()
.br
.fi
.RS
.LP
.nf
srp_public() = key_integer() 
.fi
.LP
Where is \fIA\fR\& or \fIB\fR\& from SRP design
.LP
.nf
srp_private() = key_integer() 
.fi
.LP
Where is \fIa\fR\& or \fIb\fR\& from SRP design
.RE
.nf

\fBsrp_gen_params()\fR\& = 
.br
    {user, srp_user_gen_params()} | {host, srp_host_gen_params()}
.br
.fi
.nf

\fBsrp_comp_params()\fR\& = 
.br
    {user, srp_user_comp_params()} |
.br
    {host, srp_host_comp_params()}
.br
.fi
.nf

.B
srp_user_gen_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom()]
.br
.fi
.nf

.B
srp_host_gen_params() = [Verifier::binary(), Prime::binary(), Version::atom() ]
.br
.fi
.nf

.B
srp_user_comp_params() = [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | ScramblerArg::list()]
.br
.fi
.nf

.B
srp_host_comp_params() = [Verifier::binary(), Prime::binary(), Version::atom() | ScramblerArg::list()]
.br
.fi
.RS
.LP
Where Verifier is \fIv\fR\&, Generator is \fIg\fR\& and Prime is\fI N\fR\&, DerivedKey is \fIX\fR\&, and Scrambler is \fIu\fR\& (optional will be generated if not provided) from SRP design Version = \&'3\&' | \&'6\&' | \&'6a\&'
.RE
.SS Public Key Ciphers
.nf

\fBpk_encrypt_decrypt_algs()\fR\& = rsa
.br
.fi
.RS
.LP
Algorithms for public key encrypt/decrypt\&. Only RSA is supported\&.
.RE
.nf

\fBpk_encrypt_decrypt_opts()\fR\& = [rsa_opt()] | rsa_compat_opts()
.br
.fi
.nf

\fBrsa_opt()\fR\& = 
.br
    {rsa_padding, rsa_padding()} |
.br
    {signature_md, atom()} |
.br
    {rsa_mgf1_md, sha} |
.br
    {rsa_oaep_label, binary()} |
.br
    {rsa_oaep_md, sha}
.br
.fi
.nf

\fBrsa_padding()\fR\& = 
.br
    rsa_pkcs1_padding | rsa_pkcs1_oaep_padding |
.br
    rsa_sslv23_padding | rsa_x931_padding | rsa_no_padding
.br
.fi
.RS
.LP
Options for public key encrypt/decrypt\&. Only RSA is supported\&.
.LP

.RS -4
.B
Warning:
.RE
.LP
The RSA options are experimental\&.
.LP
The exact set of options and there syntax \fImay\fR\& be changed without prior notice\&.

.RE
.nf

\fBrsa_compat_opts()\fR\& = [{rsa_pad, rsa_padding()}] | rsa_padding()
.br
.fi
.RS
.LP
Those option forms are kept only for compatibility and should not be used in new code\&.
.RE
.SS Public Key Sign and Verify
.nf

\fBpk_sign_verify_algs()\fR\& = rsa | dss | ecdsa | eddsa
.br
.fi
.RS
.LP
Algorithms for sign and verify\&.
.RE
.nf

\fBpk_sign_verify_opts()\fR\& = [rsa_sign_verify_opt()]
.br
.fi
.nf

\fBrsa_sign_verify_opt()\fR\& = 
.br
    {rsa_padding, rsa_sign_verify_padding()} |
.br
    {rsa_pss_saltlen, integer()} |
.br
    {rsa_mgf1_md, sha2()}
.br
.fi
.nf

\fBrsa_sign_verify_padding()\fR\& = 
.br
    rsa_pkcs1_padding | rsa_pkcs1_pss_padding | rsa_x931_padding |
.br
    rsa_no_padding
.br
.fi
.RS
.LP
Options for sign and verify\&.
.LP

.RS -4
.B
Warning:
.RE
.LP
The RSA options are experimental\&.
.LP
The exact set of options and there syntax \fImay\fR\& be changed without prior notice\&.

.RE
.SS Diffie-Hellman Keys and parameters
.nf

\fBdh_public()\fR\& = key_integer()
.br
.fi
.nf

\fBdh_private()\fR\& = key_integer()
.br
.fi
.RS
.RE
.nf

\fBdh_params()\fR\& = [key_integer()]
.br
.fi
.RS
.LP
.nf
dh_params() = [P, G] | [P, G, PrivateKeyBitLength]
.fi
.RE
.nf

\fBecdh_public()\fR\& = key_integer()
.br
.fi
.nf

\fBecdh_private()\fR\& = key_integer()
.br
.fi
.nf

\fBecdh_params()\fR\& = 
.br
    ec_named_curve() | edwards_curve_dh() | ec_explicit_curve()
.br
.fi
.RS
.RE
.SS Types for Engines
.nf

\fBengine_key_ref()\fR\& = 
.br
    #{engine := engine_ref(),
.br
      key_id := key_id(),
.br
      password => password(),
.br
      term() => term()}
.br
.fi
.nf

\fBengine_ref()\fR\& = term()
.br
.fi
.RS
.LP
The result of a call to engine_load/3\&.
.RE
.nf

\fBkey_id()\fR\& = string() | binary()
.br
.fi
.RS
.LP
Identifies the key to be used\&. The format depends on the loaded engine\&. It is passed to the \fIENGINE_load_(private|public)_key\fR\& functions in libcrypto\&.
.RE
.nf

\fBpassword()\fR\& = string() | binary()
.br
.fi
.RS
.LP
The password of the key stored in an engine\&.
.RE
.nf

\fBengine_method_type()\fR\& = 
.br
    engine_method_rsa | engine_method_dsa | engine_method_dh |
.br
    engine_method_rand | engine_method_ecdh |
.br
    engine_method_ecdsa | engine_method_ciphers |
.br
    engine_method_digests | engine_method_store |
.br
    engine_method_pkey_meths | engine_method_pkey_asn1_meths |
.br
    engine_method_ec
.br
.fi
.nf

\fBengine_cmnd()\fR\& = {unicode:chardata(), unicode:chardata()}
.br
.fi
.RS
.LP
Pre and Post commands for engine_load/3 and /4\&.
.RE
.SS Internal data types
.nf

\fBcrypto_state()\fR\&
.br
.fi
.nf

\fBhash_state()\fR\&
.br
.fi
.nf

\fBhmac_state()\fR\&
.br
.fi
.nf

\fBmac_state()\fR\&
.br
.fi
.nf

\fBstream_state()\fR\&
.br
.fi
.RS
.LP
Contexts with an internal state that should not be manipulated but passed between function calls\&.
.RE
.SS Error types
.nf

\fBrun_time_error()\fR\& = any()
.br
.fi
.RS
.LP
The exception \fIerror:badarg\fR\& signifies that one or more arguments are of wrong data type, or are otherwise badly formed\&.
.LP
The exception \fIerror:notsup\fR\& signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that\&.
.LP
For a list of supported algorithms, see supports/0\&.
.RE
.nf

\fBdescriptive_error()\fR\& = any()
.br
.fi
.RS
.LP
This is a more developed variant of the older run_time_error()\&.
.LP
The exception is:
.LP
.nf

	  {Tag, {C_FileName,LineNumber}, Description}

	   Tag = badarg | notsup | error
	   C_FileName = string()
	   LineNumber = integer()
	   Description = string()
	
.fi
.LP
It is like the older type an exception of the \fIerror\fR\& class\&. In addition they contain a descriptive text in English\&. That text is targeted to a developer\&. Examples are "Bad key size" or "Cipher id is not an atom"\&.
.LP
The exception tags are:
.RS 2
.TP 2
.B
\fIbadarg\fR\&:
Signifies that one or more arguments are of wrong data type or are otherwise badly formed\&.
.TP 2
.B
\fInotsup\fR\&:
Signifies that the algorithm is known but is not supported by current underlying libcrypto or explicitly disabled when building that one\&.
.TP 2
.B
\fIerror\fR\&:
An error condition that should not occur, for example a memory allocation failed or the underlying cryptolib returned an error code, for example "Can\&'t initialize context, step 1"\&. Those text usually needs searching the C-code to be understood\&.
.RE
.LP
To catch the exception, use for example:
.LP
.nf

	  try crypto:crypto_init(Ciph, Key, IV, true)
	  catch
	      error:{Tag, {C_FileName,LineNumber}, Description} ->
	              do_something(......)
	      .....
	  end
	
.fi
.RE
.SH "NEW API"

.SH EXPORTS
.LP
.nf

.B
crypto_init(Cipher, Key, FlagOrOptions) ->
.B
               State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_no_iv()
.br
Key = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
State = crypto_state()
.br
.RE
.RE
.RS
.LP
Part of the new API\&.
.LP
Equivalent to the call \fIcrypto_init(Cipher, Key, <<>>, FlagOrOptions)\fR\&\&. It is intended for ciphers without an IV (nounce)\&.
.RE
.LP
.nf

.B
crypto_init(Cipher, Key, IV, FlagOrOptions) ->
.B
               State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_iv()
.br
Key = IV = iodata()
.br
FlagOrOptions = crypto_opts()
.br
State = crypto_state()
.br
.RE
.RE
.RS
.LP
Part of the new API\&. Initializes a series of encryptions or decryptions and creates an internal state with a reference that is returned\&.
.LP
If \fIIV = <<>>\fR\&, no IV is used\&. This is intended for ciphers without an IV (nounce)\&. See crypto_init/3\&.
.LP
If \fIIV = undefined\fR\&, the IV must be added by calls to crypto_dyn_iv_update/3\&. This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption\&. See crypto_dyn_iv_init/3\&.
.LP
The actual encryption or decryption is done by crypto_update/2 (or crypto_dyn_iv_update/3 )\&.
.LP
For encryption, set the \fIFlagOrOptions\fR\& to \fItrue\fR\& or \fI[{encrypt,true}]\fR\&\&. For decryption, set it to \fIfalse\fR\& or \fI[{encrypt,false}]\fR\&\&.
.LP
Padding could be enabled with the option {padding,Padding}\&. The cryptolib_padding enables \fIpkcs_padding\fR\& or no padding (\fInone\fR\&)\&. The paddings \fIzero\fR\& or \fIrandom\fR\& fills the last part of the last block with zeroes or random bytes\&. If the last block is already full, nothing is added\&.
.LP
In decryption, the cryptolib_padding removes such padding, if present\&. The otp_padding is not removed - it has to be done elsewhere\&.
.LP
If padding is \fI{padding,none}\fR\& or not specifed and the total data from all subsequent crypto_updates does not fill the last block fully, that last data is lost\&. In case of \fI{padding,none}\fR\& there will be an error in this case\&. If padding is not specified, the bytes of the unfilled block is silently discarded\&.
.LP
The actual padding is performed by crypto_final/1\&.
.LP
For blocksizes call cipher_info/1\&.
.LP
See  examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
crypto_update(State, Data) -> Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
Data = iodata()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Part of the new API\&. It does an actual crypto operation on a part of the full text\&. If the part is less than a number of full blocks, only the full blocks (possibly none) are encrypted or decrypted and the remaining bytes are saved to the next \fIcrypto_update\fR\& operation\&. The \fIState\fR\& should be created with crypto_init/3 or crypto_init/4\&.
.LP
See  examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
crypto_dyn_iv_init(Cipher, Key, FlagOrOptions) ->
.B
                      State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_iv()
.br
Key = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
State = crypto_state()
.br
.RE
.RE
.RS
.LP
Part of the new API\&.
.LP
Initializes a series of encryptions or decryptions where the IV is provided later\&. The actual encryption or decryption is done by crypto_dyn_iv_update/3\&.
.LP
The function is equivalent to \fIcrypto_init(Cipher, Key, undefined, FlagOrOptions)\fR\&\&.
.RE
.LP
.nf

.B
crypto_final(State) -> FinalResult | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
FinalResult = binary()
.br
.RE
.RE
.RS
.LP
Part of the new API\&.
.LP
Finalizes a series of encryptions or decryptions and delivers the final bytes of the final block\&. The data returned from this function may be empty if no padding was enabled in crypto_init/3,4 or crypto_dyn_iv_init/3\&.
.RE
.LP
.nf

.B
crypto_get_data(State) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
Result = map()
.br
.RE
.RE
.RS
.LP
Part of the new API\&.
.LP
Returns information about the State in the argument\&. The information is the form of a map, which currently contains at least:
.RS 2
.TP 2
.B
\fIsize\fR\&:
The number of bytes encrypted or decrypted so far\&. 
.TP 2
.B
\fIpadding_size\fR\&:
After a call to crypto_final/1 it contains the number of bytes padded\&. Otherwise 0\&. 
.TP 2
.B
\fIpadding_type\fR\&:
The type of the padding as provided in the call ot crypto_init/3,4\&. 
.TP 2
.B
\fIencrypt\fR\&:
Is \fItrue\fR\& if encryption is performed\&. It is \fIfalse\fR\& otherwise\&. 
.RE
.RE
.LP
.nf

.B
crypto_dyn_iv_update(State, Data, IV) ->
.B
                        Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = crypto_state()
.br
Data = IV = iodata()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Part of the new API\&. Do an actual crypto operation on a part of the full text and the IV is supplied for each part\&. The \fIState\fR\& should be created with crypto_dyn_iv_init/3\&.
.RE
.LP
.nf

.B
crypto_one_time(Cipher, Key, Data, FlagOrOptions) ->
.B
                   Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_no_iv()
.br
Key = Data = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
As crypto_one_time/5 but for ciphers without IVs\&.
.RE
.LP
.nf

.B
crypto_one_time(Cipher, Key, IV, Data, FlagOrOptions) ->
.B
                   Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_iv()
.br
Key = IV = Data = iodata()
.br
FlagOrOptions = crypto_opts() | boolean()
.br
Result = binary()
.br
.RE
.RE
.RS
.LP
Part of the new API\&. Do a complete encrypt or decrypt of the full text in the argument \fIData\fR\&\&.
.LP
For encryption, set the \fIFlagOrOptions\fR\& to \fItrue\fR\&\&. For decryption, set it to \fIfalse\fR\&\&. For setting other options, see crypto_init/4\&.
.LP
See examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
crypto_one_time_aead(Cipher, Key, IV, InText, AAD,
.B
                     EncFlag :: true) ->
.B
                        Result | descriptive_error()
.br
.fi
.br
.nf

.B
crypto_one_time_aead(Cipher, Key, IV, InText, AAD, TagOrTagLength,
.B
                     EncFlag) ->
.B
                        Result | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Cipher = cipher_aead()
.br
Key = IV = InText = AAD = iodata()
.br
TagOrTagLength = EncryptTagLength | DecryptTag
.br
EncryptTagLength = integer() >= 0
.br
DecryptTag = iodata()
.br
EncFlag = boolean()
.br
Result = EncryptResult | DecryptResult
.br
EncryptResult = {OutCryptoText, OutTag}
.br
DecryptResult = OutPlainText | error
.br
OutCryptoText = OutTag = OutPlainText = binary()
.br
.RE
.RE
.RS
.LP
Part of the new API\&. Do a complete encrypt or decrypt with an AEAD cipher of the full text\&.
.LP
For encryption, set the \fIEncryptFlag\fR\& to \fItrue\fR\& and set the \fITagOrTagLength\fR\& to the wanted size (in bytes) of the tag, that is, the tag length\&. If the default length is wanted, the \fIcrypto_aead/6\fR\& form may be used\&.
.LP
For decryption, set the \fIEncryptFlag\fR\& to \fIfalse\fR\& and put the tag to be checked in the argument \fITagOrTagLength\fR\&\&.
.LP
See examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
supports(Type) -> Support
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hashs | ciphers | public_keys | macs | curves | rsa_opts
.br
Support = Hashs | Ciphers | PKs | Macs | Curves | RSAopts
.br
Hashs = 
.br
    [sha1() |
.br
     sha2() |
.br
     sha3() |
.br
     blake2() |
.br
     ripemd160 |
.br
     compatibility_only_hash()]
.br
Ciphers = [cipher()]
.br
PKs = [rsa | dss | ecdsa | dh | ecdh | eddh | ec_gf2m]
.br
Macs = [hmac | cmac | poly1305]
.br
Curves = 
.br
    [ec_named_curve() | edwards_curve_dh() | edwards_curve_ed()]
.br
RSAopts = [rsa_sign_verify_opt() | rsa_opt()]
.br
.RE
.RE
.RS
.LP
Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library
.LP
See hash_info/1 and cipher_info/1 for information about the hash and cipher algorithms\&.
.RE
.LP
.nf

.B
mac(Type :: poly1305, Key, Data) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Data = iodata()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Short for mac(Type, undefined, Key, Data)\&.
.RE
.LP
.nf

.B
mac(Type, SubType, Key, Data) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
.br
Key = Data = iodata()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Computes a MAC (Message Authentication Code) of type \fIType\fR\& from \fIData\fR\&\&.
.LP
\fISubType\fR\& depends on the MAC \fIType\fR\&:
.RS 2
.TP 2
*
For \fIhmac\fR\& it is a hash algorithm, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIcmac\fR\& it is a cipher suitable for cmac, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIpoly1305\fR\& it should be set to \fIundefined\fR\& or the mac/2 function could be used instead, see Algorithm Details in the User\&'s Guide\&. 
.LP
.RE

.LP
\fIKey\fR\& is the authentication key with a length according to the \fIType\fR\& and \fISubType\fR\&\&. The key length could be found with the hash_info/1 (\fIhmac\fR\&) for and cipher_info/1 (\fIcmac\fR\&) functions\&. For \fIpoly1305\fR\& the key length is 32 bytes\&. Note that the cryptographic quality of the key is not checked\&.
.LP
The \fIMac\fR\& result will have a default length depending on the \fIType\fR\& and \fISubType\fR\&\&. To set a shorter length, use macN/4 or macN/5 instead\&. The default length is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.LP
.nf

.B
macN(Type :: poly1305, Key, Data, MacLength) ->
.B
        Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = Data = iodata()
.br
Mac = binary()
.br
MacLength = integer() >= 1
.br
.RE
.RE
.RS
.LP
Short for macN(Type, undefined, Key, Data, MacLength)\&.
.RE
.LP
.nf

.B
macN(Type, SubType, Key, Data, MacLength) ->
.B
        Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
.br
Key = Data = iodata()
.br
Mac = binary()
.br
MacLength = integer() >= 1
.br
.RE
.RE
.RS
.LP
Computes a MAC (Message Authentication Code) as mac/3 and mac/4 but \fIMacLength\fR\& will limit the size of the resultant \fIMac\fR\& to at most \fIMacLength\fR\& bytes\&. Note that if \fIMacLength\fR\& is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead\&.
.LP
The max \fIMacLength\fR\& is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.LP
.nf

.B
mac_init(Type :: poly1305, Key) -> State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Key = iodata()
.br
State = mac_state()
.br
.RE
.RE
.RS
.LP
Short for mac_init(Type, undefined, Key)\&.
.RE
.LP
.nf

.B
mac_init(Type, SubType, Key) -> State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac | cmac | poly1305
.br
SubType = 
.br
    hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
.br
Key = iodata()
.br
State = mac_state()
.br
.RE
.RE
.RS
.LP
Initializes the context for streaming MAC operations\&.
.LP
\fIType\fR\& determines which mac algorithm to use in the MAC operation\&.
.LP
\fISubType\fR\& depends on the MAC \fIType\fR\&:
.RS 2
.TP 2
*
For \fIhmac\fR\& it is a hash algorithm, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIcmac\fR\& it is a cipher suitable for cmac, see Algorithm Details in the User\&'s Guide\&. 
.LP
.TP 2
*
For \fIpoly1305\fR\& it should be set to \fIundefined\fR\& or the mac/2 function could be used instead, see Algorithm Details in the User\&'s Guide\&. 
.LP
.RE

.LP
\fIKey\fR\& is the authentication key with a length according to the \fIType\fR\& and \fISubType\fR\&\&. The key length could be found with the hash_info/1 (\fIhmac\fR\&) for and cipher_info/1 (\fIcmac\fR\&) functions\&. For \fIpoly1305\fR\& the key length is 32 bytes\&. Note that the cryptographic quality of the key is not checked\&.
.LP
The returned \fIState\fR\& should be used in one or more subsequent calls to mac_update/2\&. The MAC value is finally returned by calling mac_final/1 or mac_finalN/2\&.
.LP
See  examples in the User\&'s Guide\&. 
.RE
.LP
.nf

.B
mac_update(State0, Data) -> State | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
State0 = State = mac_state()
.br
.RE
.RE
.RS
.LP
Updates the MAC represented by \fIState0\fR\& using the given \fIData\fR\& which could be of any length\&.
.LP
The \fIState0\fR\& is the State value originally from a MAC init function, that is mac_init/2, mac_init/3 or a previous call of \fImac_update/2\fR\&\&. The value \fIState0\fR\& is returned unchanged by the function as \fIState\fR\&\&.
.RE
.LP
.nf

.B
mac_final(State) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = mac_state()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Finalizes the MAC operation referenced by \fIState\fR\&\&. The \fIMac\fR\& result will have a default length depending on the \fIType\fR\& and \fISubType\fR\& in the mac_init/2,3 call\&. To set a shorter length, use mac_finalN/2 instead\&. The default length is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.LP
.nf

.B
mac_finalN(State, MacLength) -> Mac | descriptive_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = mac_state()
.br
MacLength = integer() >= 1
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP
Finalizes the MAC operation referenced by \fIState\fR\&\&.
.LP
\fIMac\fR\& will be a binary with at most \fIMacLength\fR\& bytes\&. Note that if \fIMacLength\fR\& is greater than the actual number of bytes returned from the underlying hash, the returned hash will have that shorter length instead\&.
.LP
The max \fIMacLength\fR\& is documented in Algorithm Details in the User\&'s Guide\&.
.RE
.SH "API KEPT FROM PREVIOUS VERSIONS"

.SH EXPORTS
.LP
.nf

.B
bytes_to_integer(Bin :: binary()) -> integer()
.br
.fi
.br
.RS
.LP
Convert binary representation, of an integer, to an Erlang integer\&.
.RE
.LP
.nf

.B
compute_key(Type, OthersPublicKey, MyPrivateKey, Params) ->
.B
               SharedSecret
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = dh | ecdh | eddh | srp
.br
SharedSecret = binary()
.br
OthersPublicKey = dh_public() | ecdh_public() | srp_public()
.br
MyPrivateKey = 
.br
    dh_private() | ecdh_private() | {srp_public(), srp_private()}
.br
Params = dh_params() | ecdh_params() | srp_comp_params()
.br
.RE
.RE
.RS
.LP
Computes the shared secret from the private key and the other party\&'s public key\&. See also public_key:compute_key/2 
.RE
.LP
.nf

.B
exor(Bin1 :: iodata(), Bin2 :: iodata()) -> binary()
.br
.fi
.br
.RS
.LP
Performs bit-wise XOR (exclusive or) on the data supplied\&.
.RE
.LP
.nf

.B
generate_key(Type, Params) -> {PublicKey, PrivKeyOut}
.br
.fi
.br
.nf

.B
generate_key(Type, Params, PrivKeyIn) -> {PublicKey, PrivKeyOut}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = dh | ecdh | eddh | eddsa | rsa | srp
.br
PublicKey = 
.br
    dh_public() | ecdh_public() | rsa_public() | srp_public()
.br
PrivKeyIn = 
.br
    undefined |
.br
    dh_private() |
.br
    ecdh_private() |
.br
    rsa_private() |
.br
    {srp_public(), srp_private()}
.br
PrivKeyOut = 
.br
    dh_private() |
.br
    ecdh_private() |
.br
    rsa_private() |
.br
    {srp_public(), srp_private()}
.br
Params = 
.br
    dh_params() |
.br
    ecdh_params() |
.br
    eddsa_params() |
.br
    rsa_params() |
.br
    srp_comp_params()
.br
.RE
.RE
.RS
.LP
Generates a public key of type \fIType\fR\&\&. See also public_key:generate_key/1\&. May raise exception:
.RS 2
.TP 2
*
\fIerror:badarg\fR\&: an argument is of wrong type or has an illegal value,
.LP
.TP 2
*
\fIerror:low_entropy\fR\&: the random generator failed due to lack of secure "randomness",
.LP
.TP 2
*
\fIerror:computation_failed\fR\&: the computation fails of another reason than \fIlow_entropy\fR\&\&.
.LP
.RE

.LP

.RS -4
.B
Note:
.RE
RSA key generation is only available if the runtime was built with dirty scheduler support\&. Otherwise, attempting to generate an RSA key will raise exception \fIerror:notsup\fR\&\&.

.RE
.LP
.nf

.B
hash(Type, Data) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hash_algorithm()
.br
Data = iodata()
.br
Digest = binary()
.br
.RE
.RE
.RS
.LP
Computes a message digest of type \fIType\fR\& from \fIData\fR\&\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.RE
.LP
.nf

.B
hash_init(Type) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hash_algorithm()
.br
State = hash_state()
.br
.RE
.RE
.RS
.LP
Initializes the context for streaming hash operations\&. \fIType\fR\& determines which digest to use\&. The returned context should be used as argument to hash_update\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.RE
.LP
.nf

.B
hash_update(State, Data) -> NewState
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = NewState = hash_state()
.br
Data = iodata()
.br
.RE
.RE
.RS
.LP
Updates the digest represented by \fIContext\fR\& using the given \fIData\fR\&\&. \fIContext\fR\& must have been generated using hash_init or a previous call to this function\&. \fIData\fR\& can be any length\&. \fINewContext\fR\& must be passed into the next call to \fIhash_update\fR\& or hash_final\&.
.RE
.LP
.nf

.B
hash_final(State) -> Digest
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = hash_state()
.br
Digest = binary()
.br
.RE
.RE
.RS
.LP
Finalizes the hash operation referenced by \fIContext\fR\& returned from a previous call to hash_update\&. The size of \fIDigest\fR\& is determined by the type of hash function used to generate it\&.
.RE
.LP
.nf

.B
info_fips() -> not_supported | not_enabled | enabled
.br
.fi
.br
.RS
.LP
Provides information about the FIPS operating status of crypto and the underlying libcrypto library\&. If crypto was built with FIPS support this can be either \fIenabled\fR\& (when running in FIPS mode) or \fInot_enabled\fR\&\&. For other builds this value is always \fInot_supported\fR\&\&.
.LP
See enable_fips_mode/1 about how to enable FIPS mode\&.
.LP

.RS -4
.B
Warning:
.RE
In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception \fIerror:notsup\fR\&\&. Check supports that in FIPS mode returns the restricted list of available algorithms\&.

.RE
.LP
.nf

.B
enable_fips_mode(Enable) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Enable = Result = boolean()
.br
.RE
.RE
.RS
.LP
Enables (\fIEnable = true\fR\&) or disables (\fIEnable = false\fR\&) FIPS mode\&. Returns \fItrue\fR\& if the operation was successful or \fIfalse\fR\& otherwise\&.
.LP
Note that to enable FIPS mode succesfully, OTP must be built with the configure option \fI--enable-fips\fR\&, and the underlying libcrypto must also support FIPS\&.
.LP
See also info_fips/0\&.
.RE
.LP
.nf

.B
info_lib() -> [{Name, VerNum, VerStr}]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Name = binary()
.br
VerNum = integer()
.br
VerStr = binary()
.br
.RE
.RE
.RS
.LP
Provides the name and version of the libraries used by crypto\&.
.LP
\fIName\fR\& is the name of the library\&. \fIVerNum\fR\& is the numeric version according to the library\&'s own versioning scheme\&. \fIVerStr\fR\& contains a text variant of the version\&.
.LP
.nf

> info_lib()\&.
[{<<"OpenSSL">>,269484095,<<"OpenSSL 1.1.0c  10 Nov 2016"">>}]
        
.fi
.LP

.RS -4
.B
Note:
.RE
From OTP R16 the \fInumeric version\fR\& represents the version of the OpenSSL \fIheader files\fR\& (\fIopenssl/opensslv\&.h\fR\&) used when crypto was compiled\&. The text variant represents the libcrypto library used at runtime\&. In earlier OTP versions both numeric and text was taken from the library\&.

.RE
.LP
.nf

.B
hash_info(Type) -> Result | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hash_algorithm()
.br
Result = 
.br
    #{size := integer(),
.br
      block_size := integer(),
.br
      type := integer()}
.br
.RE
.RE
.RS
.LP
Provides a map with information about block_size, size and possibly other properties of the hash algorithm in question\&.
.LP
For a list of supported hash algorithms, see supports/0\&.
.RE
.LP
.nf

.B
cipher_info(Type) -> Result | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = cipher()
.br
Result = 
.br
    #{key_length := integer(),
.br
      iv_length := integer(),
.br
      block_size := integer(),
.br
      mode := CipherModes,
.br
      type := undefined | integer()}
.br
CipherModes = 
.br
    undefined | cbc_mode | ccm_mode | cfb_mode | ctr_mode |
.br
    ecb_mode | gcm_mode | ige_mode | ocb_mode | ofb_mode |
.br
    wrap_mode | xts_mode
.br
.RE
.RE
.RS
.LP
Provides a map with information about block_size, key_length, iv_length and possibly other properties of the cipher algorithm in question\&.
.LP

.RS -4
.B
Note:
.RE
The ciphers \fIaes_cbc\fR\&, \fIaes_cfb8\fR\&, \fIaes_cfb128\fR\&, \fIaes_ctr\fR\&, \fIaes_ecb\fR\&, \fIaes_gcm\fR\& and \fIaes_ccm\fR\& has no keylength in the \fIType\fR\& as opposed to for example \fIaes_128_ctr\fR\&\&. They adapt to the length of the key provided in the encrypt and decrypt function\&. Therefor it is impossible to return a valid keylength in the map\&.
.LP
Always use a \fIType\fR\& with an explicit key length,

.LP
For a list of supported cipher algorithms, see supports/0\&.
.RE
.LP
.nf

.B
mod_pow(N, P, M) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
N = P = M = binary() | integer()
.br
Result = binary() | error
.br
.RE
.RE
.RS
.LP
Computes the function \fIN^P mod M\fR\&\&.
.RE
.LP
.nf

.B
next_iv(Type :: cbc_cipher(), Data) -> NextIVec
.br
.fi
.br
.nf

.B
next_iv(Type :: des_cfb, Data, IVec) -> NextIVec
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
IVec = NextIVec = binary()
.br
.RE
.RE
.RS
.LP
Returns the initialization vector to be used in the next iteration of encrypt/decrypt of type \fIType\fR\&\&. \fIData\fR\& is the encrypted data from the previous iteration step\&. The \fIIVec\fR\& argument is only needed for \fIdes_cfb\fR\& as the vector used in the previous iteration step\&.
.RE
.LP
.nf

.B
private_decrypt(Algorithm, CipherText, PrivateKey, Options) ->
.B
                   PlainText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
CipherText = binary()
.br
PrivateKey = rsa_private() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
PlainText = binary()
.br
.RE
.RE
.RS
.LP
Decrypts the \fICipherText\fR\&, encrypted with public_encrypt/4 (or equivalent function) using the \fIPrivateKey\fR\&, and returns the plaintext (message digest)\&. This is a low level signature verification operation used for instance by older versions of the SSL protocol\&. See also public_key:decrypt_private/[2,3] 
.RE
.LP
.nf

.B
private_encrypt(Algorithm, PlainText, PrivateKey, Options) ->
.B
                   CipherText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
PlainText = binary()
.br
PrivateKey = rsa_private() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
CipherText = binary()
.br
.RE
.RE
.RS
.LP
Encrypts the \fIPlainText\fR\& using the \fIPrivateKey\fR\& and returns the ciphertext\&. This is a low level signature operation used for instance by older versions of the SSL protocol\&. See also public_key:encrypt_private/[2,3] 
.RE
.LP
.nf

.B
public_decrypt(Algorithm, CipherText, PublicKey, Options) ->
.B
                  PlainText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
CipherText = binary()
.br
PublicKey = rsa_public() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
PlainText = binary()
.br
.RE
.RE
.RS
.LP
Decrypts the \fICipherText\fR\&, encrypted with private_encrypt/4(or equivalent function) using the \fIPrivateKey\fR\&, and returns the plaintext (message digest)\&. This is a low level signature verification operation used for instance by older versions of the SSL protocol\&. See also public_key:decrypt_public/[2,3] 
.RE
.LP
.nf

.B
public_encrypt(Algorithm, PlainText, PublicKey, Options) ->
.B
                  CipherText
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_encrypt_decrypt_algs()
.br
PlainText = binary()
.br
PublicKey = rsa_public() | engine_key_ref()
.br
Options = pk_encrypt_decrypt_opts()
.br
CipherText = binary()
.br
.RE
.RE
.RS
.LP
Encrypts the \fIPlainText\fR\& (message digest) using the \fIPublicKey\fR\& and returns the \fICipherText\fR\&\&. This is a low level signature operation used for instance by older versions of the SSL protocol\&. See also public_key:encrypt_public/[2,3] 
.RE
.LP
.nf

.B
rand_seed(Seed :: binary()) -> ok
.br
.fi
.br
.RS
.LP
Set the seed for PRNG to the given binary\&. This calls the RAND_seed function from openssl\&. Only use this if the system you are running on does not have enough "randomness" built in\&. Normally this is when strong_rand_bytes/1 raises \fIerror:low_entropy\fR\&
.RE
.LP
.B
rand_uniform(Lo, Hi) -> N
.br
.RS
.LP
Types:

.RS 3
Lo, Hi, N = integer()
.br
.RE
.RE
.RS
.LP
Generate a random number \fIN, Lo =< N < Hi\&.\fR\& Uses the \fIcrypto\fR\& library pseudo-random number generator\&. \fIHi\fR\& must be larger than \fILo\fR\&\&.
.RE
.LP
.nf

.B
start() -> ok | {error, Reason :: term()}
.br
.fi
.br
.RS
.LP
Equivalent to application:start(crypto)\&.
.RE
.LP
.nf

.B
stop() -> ok | {error, Reason :: term()}
.br
.fi
.br
.RS
.LP
Equivalent to application:stop(crypto)\&.
.RE
.LP
.nf

.B
strong_rand_bytes(N :: integer() >= 0) -> binary()
.br
.fi
.br
.RS
.LP
Generates N bytes randomly uniform 0\&.\&.255, and returns the result in a binary\&. Uses a cryptographically secure prng seeded and periodically mixed with operating system provided entropy\&. By default this is the \fIRAND_bytes\fR\& method from OpenSSL\&.
.LP
May raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.RE
.LP
.nf

.B
rand_seed() -> rand:state()
.br
.fi
.br
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strong random numbers (based on OpenSSL\&'s \fIBN_rand_range\fR\&), and saves it in the process dictionary before returning it as well\&. See also rand:seed/1 and rand_seed_s/0\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed(),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[
.fi
.RE
.LP
.nf

.B
rand_seed_s() -> rand:state()
.br
.fi
.br
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strongly random numbers (based on OpenSSL\&'s \fIBN_rand_range\fR\&)\&. See also rand:seed_s/1\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP

.RS -4
.B
Note:
.RE
The state returned from this function cannot be used to get a reproducable random sequence as from the other rand functions, since reproducability does not match cryptographically safe\&.
.LP
The only supported usage is to generate one distinct random sequence from this start state\&.

.RE
.LP
.B
rand_seed_alg(Alg) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto | crypto_cache
.br
.RE
.RE
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strong random numbers, and saves it in the process dictionary before returning it as well\&. See also rand:seed/1 and rand_seed_alg_s/1\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed_alg(crypto_cache),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[
.fi
.RE
.LP
.B
rand_seed_alg(Alg, Seed) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto_aes
.br
.RE
.RE
.RS
.LP
Creates a state object for random number generation, in order to generate cryptographically unpredictable random numbers, and saves it in the process dictionary before returning it as well\&. See also rand_seed_alg_s/2\&.
.LP
\fIExample\fR\&
.LP
.nf

_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % [1; 42]
FloatValue = rand:uniform(),     % [0.0; 1.0[
_ = crypto:rand_seed_alg(crypto_aes, "my seed"),
IntegerValue = rand:uniform(42), % Same values
FloatValue = rand:uniform().     % again
	
.fi
.RE
.LP
.B
rand_seed_alg_s(Alg) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto | crypto_cache
.br
.RE
.RE
.RS
.LP
Creates state object for random number generation, in order to generate cryptographically strongly random numbers\&. See also rand:seed_s/1\&.
.LP
If \fIAlg\fR\& is \fIcrypto\fR\& this function behaves exactly like rand_seed_s/0\&.
.LP
If \fIAlg\fR\& is \fIcrypto_cache\fR\& this function fetches random data with OpenSSL\&'s \fIRAND_bytes\fR\& and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines\&.
.LP
When using the state object from this function the rand functions using it may raise exception \fIerror:low_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP
The cache size can be changed from its default value using the  crypto app\&'s  configuration parameter \fIrand_cache_size\fR\&\&.
.LP
When using the state object from this function the rand functions using it may throw exception \fIlow_entropy\fR\& in case the random generator failed due to lack of secure "randomness"\&.
.LP

.RS -4
.B
Note:
.RE
The state returned from this function cannot be used to get a reproducable random sequence as from the other rand functions, since reproducability does not match cryptographically safe\&.
.LP
In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable\&.
.LP
The only supported usage is to generate one distinct random sequence from this start state\&.

.RE
.LP
.B
rand_seed_alg_s(Alg, Seed) -> rand:state()
.br
.RS
.LP
Types:

.RS 3
Alg = crypto_aes
.br
.RE
.RE
.RS
.LP
Creates a state object for random number generation, in order to generate cryptographically unpredictable random numbers\&. See also rand_seed_alg/1\&.
.LP
To get a long period the Xoroshiro928 generator from the rand module is used as a counter (with period 2^928 - 1) and the generator states are scrambled through AES to create 58-bit pseudo random values\&.
.LP
The result should be statistically completely unpredictable random values, since the scrambling is cryptographically strong and the period is ridiculously long\&. But the generated numbers are not to be regarded as cryptographically strong since there is no re-keying schedule\&.
.RS 2
.TP 2
*
If you need cryptographically strong random numbers use rand_seed_alg_s/1 with \fIAlg =:= crypto\fR\& or \fIAlg =:= crypto_cache\fR\&\&.
.LP
.TP 2
*
If you need to be able to repeat the sequence use this function\&.
.LP
.TP 2
*
If you do not need the statistical quality of this function, there are faster algorithms in the rand module\&.
.LP
.RE

.LP
Thanks to the used generator the state object supports the \fIrand:jump/0,1\fR\& function with distance 2^512\&.
.LP
Numbers are generated in batches and cached for speed reasons\&. The cache size can be changed from its default value using the  crypto app\&'s  configuration parameter \fIrand_cache_size\fR\&\&.
.RE
.LP
.nf

.B
ec_curves() -> [EllipticCurve]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EllipticCurve = 
.br
    ec_named_curve() | edwards_curve_dh() | edwards_curve_ed()
.br
.RE
.RE
.RS
.LP
Can be used to determine which named elliptic curves are supported\&.
.RE
.LP
.nf

.B
ec_curve(CurveName) -> ExplicitCurve
.br
.fi
.br
.RS
.LP
Types:

.RS 3
CurveName = ec_named_curve()
.br
ExplicitCurve = ec_explicit_curve()
.br
.RE
.RE
.RS
.LP
Return the defining parameters of a elliptic curve\&.
.RE
.LP
.nf

.B
sign(Algorithm, DigestType, Msg, Key) -> Signature
.br
.fi
.br
.nf

.B
sign(Algorithm, DigestType, Msg, Key, Options) -> Signature
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_sign_verify_algs()
.br
DigestType = 
.br
    rsa_digest_type() |
.br
    dss_digest_type() |
.br
    ecdsa_digest_type() |
.br
    none
.br
Msg = iodata() | {digest, iodata()}
.br
Key = 
.br
    rsa_private() |
.br
    dss_private() |
.br
    [ecdsa_private() | ecdsa_params()] |
.br
    [eddsa_private() | eddsa_params()] |
.br
    engine_key_ref()
.br
Options = pk_sign_verify_opts()
.br
Signature = binary()
.br
.RE
.RE
.RS
.LP
Creates a digital signature\&.
.LP
The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i\&.e\&. the digest (plaintext)\&.
.LP
Algorithm \fIdss\fR\& can only be used together with digest type \fIsha\fR\&\&.
.LP
See also public_key:sign/3\&.
.RE
.LP
.nf

.B
verify(Algorithm, DigestType, Msg, Signature, Key) -> Result
.br
.fi
.br
.nf

.B
verify(Algorithm, DigestType, Msg, Signature, Key, Options) ->
.B
          Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Algorithm = pk_sign_verify_algs()
.br
DigestType = 
.br
    rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()
.br
Msg = iodata() | {digest, iodata()}
.br
Signature = binary()
.br
Key = 
.br
    rsa_public() |
.br
    dss_public() |
.br
    [ecdsa_public() | ecdsa_params()] |
.br
    [eddsa_public() | eddsa_params()] |
.br
    engine_key_ref()
.br
Options = pk_sign_verify_opts()
.br
Result = boolean()
.br
.RE
.RE
.RS
.LP
Verifies a digital signature
.LP
The msg is either the binary "cleartext" data to be signed or it is the hashed value of "cleartext" i\&.e\&. the digest (plaintext)\&.
.LP
Algorithm \fIdss\fR\& can only be used together with digest type \fIsha\fR\&\&.
.LP
See also public_key:verify/4\&.
.RE
.SH "ENGINE API"

.SH EXPORTS
.LP
.nf

.B
privkey_to_pubkey(Type, EnginePrivateKeyRef) -> PublicKey
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = rsa | dss
.br
EnginePrivateKeyRef = engine_key_ref()
.br
PublicKey = rsa_public() | dss_public()
.br
.RE
.RE
.RS
.LP
Fetches the corresponding public key from a private key stored in an Engine\&. The key must be of the type indicated by the Type parameter\&.
.RE
.LP
.nf

.B
engine_get_all_methods() -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = [engine_method_type()]
.br
.RE
.RE
.RS
.LP
Returns a list of all possible engine methods\&.
.LP
May raise exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_load(EngineId, PreCmds, PostCmds) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = unicode:chardata()
.br
PreCmds = PostCmds = [engine_cmnd()]
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& if it is available and then returns ok and an engine handle\&. This function is the same as calling \fIengine_load/4\fR\& with \fIEngineMethods\fR\& set to a list of all the possible methods\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_load(EngineId, PreCmds, PostCmds, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = unicode:chardata()
.br
PreCmds = PostCmds = [engine_cmnd()]
.br
EngineMethods = [engine_method_type()]
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& if it is available and then returns ok and an engine handle\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_unload(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unloads the OpenSSL engine given by \fIEngine\fR\&\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameter is in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_by_id(EngineId) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = unicode:chardata()
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Get a reference to an already loaded engine with \fIEngineId\fR\&\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameter is in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
engine_ctrl_cmd_string(Engine, CmdName, CmdArg) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = term()
.br
CmdName = CmdArg = unicode:chardata()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Sends ctrl commands to the OpenSSL engine given by \fIEngine\fR\&\&. This function is the same as calling \fIengine_ctrl_cmd_string/4\fR\& with \fIOptional\fR\& set to \fIfalse\fR\&\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_ctrl_cmd_string(Engine, CmdName, CmdArg, Optional) ->
.B
                          Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = term()
.br
CmdName = CmdArg = unicode:chardata()
.br
Optional = boolean()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Sends ctrl commands to the OpenSSL engine given by \fIEngine\fR\&\&. \fIOptional\fR\& is a boolean argument that can relax the semantics of the function\&. If set to \fItrue\fR\& it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn\&'t support the command name it will simply return success without doing anything\&. In this case we assume the user is only supplying commands specific to the given ENGINE so we set this to \fIfalse\fR\&\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_add(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Add the engine to OpenSSL\&'s internal list\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_remove(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Remove the engine from OpenSSL\&'s internal list\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_get_id(Engine) -> EngineId
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
EngineId = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Return the ID for the engine, or an empty binary if there is no id set\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_get_name(Engine) -> EngineName
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
EngineName = unicode:chardata()
.br
.RE
.RE
.RS
.LP
Return the name (eg a description) for the engine, or an empty binary if there is no name set\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
engine_list() -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Result = [EngineId :: unicode:chardata()]
.br
.RE
.RE
.RS
.LP
List the id\&'s of all engines in OpenSSL\&'s internal list\&.
.LP
It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.LP
May raise exception \fIerror:notsup\fR\& in case engine functionality is not supported by the underlying OpenSSL implementation\&.
.RE
.LP
.nf

.B
ensure_engine_loaded(EngineId, LibPath) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = LibPath = unicode:chardata()
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& and the path to the dynamic library implementing the engine\&. This function is the same as calling \fIensure_engine_loaded/3\fR\& with \fIEngineMethods\fR\& set to a list of all the possible methods\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
ensure_engine_loaded(EngineId, LibPath, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
EngineId = LibPath = unicode:chardata()
.br
EngineMethods = [engine_method_type()]
.br
Result = 
.br
    {ok, Engine :: engine_ref()} | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Loads the OpenSSL engine given by \fIEngineId\fR\& and the path to the dynamic library implementing the engine\&. This function differs from the normal engine_load in that sense it also add the engine id to the internal list in OpenSSL\&. Then in the following calls to the function it just fetch the reference to the engine instead of loading it again\&. An error tuple is returned if the engine can\&'t be loaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
ensure_engine_unloaded(Engine) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unloads an engine loaded with the \fIensure_engine_loaded\fR\& function\&. It both removes the label from the OpenSSL internal engine list and unloads the engine\&. This function is the same as calling \fIensure_engine_unloaded/2\fR\& with \fIEngineMethods\fR\& set to a list of all the possible methods\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.LP
.nf

.B
ensure_engine_unloaded(Engine, EngineMethods) -> Result
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Engine = engine_ref()
.br
EngineMethods = [engine_method_type()]
.br
Result = ok | {error, Reason :: term()}
.br
.RE
.RE
.RS
.LP
Unloads an engine loaded with the \fIensure_engine_loaded\fR\& function\&. It both removes the label from the OpenSSL internal engine list and unloads the engine\&. An error tuple is returned if the engine can\&'t be unloaded\&.
.LP
The function raises a \fIerror:badarg\fR\& if the parameters are in wrong format\&. It may also raise the exception \fIerror:notsup\fR\& in case there is no engine support in the underlying OpenSSL implementation\&.
.LP
See also the chapter Engine Load in the User\&'s Guide\&.
.RE
.SH "OLD API"

.SH EXPORTS
.LP
.nf

.B
block_encrypt(Type :: block_cipher_without_iv(),
.B
              Key :: key(),
.B
              PlainText :: iodata()) ->
.B
                 binary() | run_time_error()
.br
.fi
.br
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the-new-api\&.

.LP
Encrypt \fIPlainText\fR\& according to \fIType\fR\& block cipher\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths and blocksizes see the User\&'s Guide\&.
.RE
.LP
.nf

.B
block_decrypt(Type :: block_cipher_without_iv(),
.B
              Key :: key(),
.B
              Data :: iodata()) ->
.B
                 binary() | run_time_error()
.br
.fi
.br
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the new api\&.

.LP
Decrypt \fICipherText\fR\& according to \fIType\fR\& block cipher\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths and blocksizes see the User\&'s Guide\&.
.RE
.LP
.B
block_encrypt(Type, Key, Ivec, PlainText) -> CipherText | Error
.br
.B
block_encrypt(AeadType, Key, Ivec, {AAD, PlainText}) -> {CipherText, CipherTag} | Error
.br
.B
block_encrypt(aes_gcm | aes_ccm, Key, Ivec, {AAD, PlainText, TagLength}) -> {CipherText, CipherTag} | Error 
.br
.RS
.LP
Types:

.RS 3
Type = block_cipher_with_iv()
.br
AeadType = aead_cipher()
.br
Key = key() | des3_key()
.br
PlainText = iodata()
.br
AAD = IVec = CipherText = CipherTag = binary()
.br
TagLength = 1\&.\&.16
.br
Error = run_time_error()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the new api\&.

.LP
Encrypt \fIPlainText\fR\& according to \fIType\fR\& block cipher\&. \fIIVec\fR\& is an arbitrary initializing vector\&.
.LP
In AEAD (Authenticated Encryption with Associated Data) mode, encrypt \fIPlainText\fR\&according to \fIType\fR\& block cipher and calculate \fICipherTag\fR\& that also authenticates the \fIAAD\fR\& (Associated Authenticated Data)\&.
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths, iv-sizes and blocksizes see the User\&'s Guide\&.
.RE
.LP
.B
block_decrypt(Type, Key, Ivec, CipherText) -> PlainText | Error
.br
.B
block_decrypt(AeadType, Key, Ivec, {AAD, CipherText, CipherTag}) -> PlainText | Error
.br
.RS
.LP
Types:

.RS 3
Type = block_cipher_with_iv()
.br
AeadType = aead_cipher()
.br
Key = key() | des3_key()
.br
PlainText = iodata()
.br
AAD = IVec = CipherText = CipherTag = binary()
.br
Error = BadTag | run_time_error()
.br
BadTag = error
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the new api\&.

.LP
Decrypt \fICipherText\fR\& according to \fIType\fR\& block cipher\&. \fIIVec\fR\& is an arbitrary initializing vector\&.
.LP
In AEAD (Authenticated Encryption with Associated Data) mode, decrypt \fICipherText\fR\&according to \fIType\fR\& block cipher and check the authenticity the \fIPlainText\fR\& and \fIAAD\fR\& (Associated Authenticated Data) using the \fICipherTag\fR\&\&. May return \fIerror\fR\& if the decryption or validation fail\&'s
.LP
May raise exception \fIerror:notsup\fR\& in case the chosen \fIType\fR\& is not supported by the underlying libcrypto implementation\&.
.LP
For keylengths, iv-sizes and blocksizes see the User\&'s Guide\&.
.RE
.LP
.nf

.B
stream_init(Type, Key) -> State | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = rc4
.br
Key = iodata()
.br
State = stream_state()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the new api\&.

.LP
Initializes the state for use in RC4 stream encryption stream_encrypt and stream_decrypt
.LP
For keylengths see the User\&'s Guide\&.
.RE
.LP
.nf

.B
stream_init(Type, Key, IVec) -> State | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = stream_cipher()
.br
Key = iodata()
.br
IVec = binary()
.br
State = stream_state()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the new api\&.

.LP
Initializes the state for use in streaming AES encryption using Counter mode (CTR)\&. \fIKey\fR\& is the AES key and must be either 128, 192, or 256 bits long\&. \fIIVec\fR\& is an arbitrary initializing vector of 128 bits (16 bytes)\&. This state is for use with stream_encrypt and stream_decrypt\&.
.LP
For keylengths and iv-sizes see the User\&'s Guide\&.
.RE
.LP
.nf

.B
stream_encrypt(State, PlainText) ->
.B
                  {NewState, CipherText} | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = stream_state()
.br
PlainText = iodata()
.br
NewState = stream_state()
.br
CipherText = iodata()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the new api\&.

.LP
Encrypts \fIPlainText\fR\& according to the stream cipher \fIType\fR\& specified in stream_init/3\&. \fIText\fR\& can be any number of bytes\&. The initial \fIState\fR\& is created using stream_init\&. \fINewState\fR\& must be passed into the next call to \fIstream_encrypt\fR\&\&.
.RE
.LP
.nf

.B
stream_decrypt(State, CipherText) ->
.B
                  {NewState, PlainText} | run_time_error()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = stream_state()
.br
CipherText = iodata()
.br
NewState = stream_state()
.br
PlainText = iodata()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use the new api\&.

.LP
Decrypts \fICipherText\fR\& according to the stream cipher \fIType\fR\& specified in stream_init/3\&. \fIPlainText\fR\& can be any number of bytes\&. The initial \fIState\fR\& is created using stream_init\&. \fINewState\fR\& must be passed into the next call to \fIstream_decrypt\fR\&\&.
.RE
.LP
.nf

.B
supports() -> [Support]
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Support = 
.br
    {hashs, Hashs} |
.br
    {ciphers, Ciphers} |
.br
    {public_keys, PKs} |
.br
    {macs, Macs} |
.br
    {curves, Curves} |
.br
    {rsa_opts, RSAopts}
.br
Hashs = 
.br
    [sha1() |
.br
     sha2() |
.br
     sha3() |
.br
     blake2() |
.br
     ripemd160 |
.br
     compatibility_only_hash()]
.br
Ciphers = [cipher()]
.br
PKs = [rsa | dss | ecdsa | dh | ecdh | eddh | ec_gf2m]
.br
Macs = [hmac | cmac | poly1305]
.br
Curves = 
.br
    [ec_named_curve() | edwards_curve_dh() | edwards_curve_ed()]
.br
RSAopts = [rsa_sign_verify_opt() | rsa_opt()]
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use supports/1 in the new api\&.

.LP
Can be used to determine which crypto algorithms that are supported by the underlying libcrypto library
.LP
See hash_info/1 and cipher_info/1 for information about the hash and cipher algorithms\&.
.RE
.LP
.nf

.B
hmac(Type, Key, Data) -> Mac
.br
.fi
.br
.nf

.B
hmac(Type, Key, Data, MacLength) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac_hash_algorithm()
.br
Key = Data = iodata()
.br
MacLength = integer()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use mac/4 or macN/5 in the new api\&.

.LP
Computes a HMAC of type \fIType\fR\& from \fIData\fR\& using \fIKey\fR\& as the authentication key\&.
.LP
\fIMacLength\fR\& will limit the size of the resultant \fIMac\fR\&\&.
.RE
.LP
.nf

.B
hmac_init(Type, Key) -> State
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = hmac_hash_algorithm()
.br
Key = iodata()
.br
State = hmac_state()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use mac_init/3 in the new api\&.

.LP
Initializes the context for streaming HMAC operations\&. \fIType\fR\& determines which hash function to use in the HMAC operation\&. \fIKey\fR\& is the authentication key\&. The key can be any length\&.
.RE
.LP
.nf

.B
hmac_update(State, Data) -> NewState
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Data = iodata()
.br
State = NewState = hmac_state()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use mac_update/2 in the new api\&.

.LP
Updates the HMAC represented by \fIContext\fR\& using the given \fIData\fR\&\&. \fIContext\fR\& must have been generated using an HMAC init function (such as hmac_init)\&. \fIData\fR\& can be any length\&. \fINewContext\fR\& must be passed into the next call to \fIhmac_update\fR\& or to one of the functions hmac_final and hmac_final_n 
.LP

.RS -4
.B
Warning:
.RE
Do not use a \fIContext\fR\& as argument in more than one call to hmac_update or hmac_final\&. The semantics of reusing old contexts in any way is undefined and could even crash the VM in earlier releases\&. The reason for this limitation is a lack of support in the underlying libcrypto API\&.

.RE
.LP
.nf

.B
hmac_final(State) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = hmac_state()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use mac_final/1 in the new api\&.

.LP
Finalizes the HMAC operation referenced by \fIContext\fR\&\&. The size of the resultant MAC is determined by the type of hash function used to generate it\&.
.RE
.LP
.nf

.B
hmac_final_n(State, HashLen) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
State = hmac_state()
.br
HashLen = integer()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use mac_finalN/2 in the new api\&.

.LP
Finalizes the HMAC operation referenced by \fIContext\fR\&\&. \fIHashLen\fR\& must be greater than zero\&. \fIMac\fR\& will be a binary with at most \fIHashLen\fR\& bytes\&. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than \fIHashLen\fR\& bytes\&.
.RE
.LP
.nf

.B
cmac(Type, Key, Data) -> Mac
.br
.fi
.br
.nf

.B
cmac(Type, Key, Data, MacLength) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Type = 
.br
    cbc_cipher() |
.br
    cfb_cipher() |
.br
    blowfish_cbc | des_ede3 | rc2_cbc
.br
Key = Data = iodata()
.br
MacLength = integer()
.br
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use mac/4 or macN/5 in the new api\&.

.LP
Computes a CMAC of type \fIType\fR\& from \fIData\fR\& using \fIKey\fR\& as the authentication key\&.
.LP
\fIMacLength\fR\& will limit the size of the resultant \fIMac\fR\&\&.
.RE
.LP
.nf

.B
poly1305(Key :: iodata(), Data :: iodata()) -> Mac
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Mac = binary()
.br
.RE
.RE
.RS
.LP

.RS -4
.B
Dont:
.RE
Don\&'t use this function for new programs! Use mac/3 or macN/4 in the new api\&.

.LP
Computes a POLY1305 message authentication code (\fIMac\fR\&) from \fIData\fR\& using \fIKey\fR\& as the authentication key\&.
.RE